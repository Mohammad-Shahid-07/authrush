{
  "name": "Prisma.user.actions",

  "files": [
    {
      "name": "user.actions.ts",
      "imports": "",
      "content": "\"use server\"\n import { database } from \"@/lib/database\";\nimport { currentUser } from \"@/lib/utils/currentSession\";\n\nimport { revalidatePath } from \"next/cache\";\nimport bcrypt from \"bcryptjs\";\nimport { signOut } from \"@/auth\";\n type UpdateUserImageProps = {\n  image: string;\n  path: string;\n};\nexport async function updateUserImage(params: UpdateUserImageProps) {\n  try {\n    const { image, path } = params;\n\n    const userSession = await currentUser();\n    if (!userSession) {\n      return null;\n    }\n\n    const user = await database.user.findFirst({\n      where: {\n        email: userSession.email,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    await database.user.update({\n      where: {\n        id: user.id,\n      },\n      data: {\n        image: image,\n      },\n    });\n\n    userSession.image = image;\n\n    revalidatePath(path);\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\ntype UpdateUserNameUserProps = {\n  name: string;\n  username?: string;\n  pathname: string;\n};\n\nexport async function updateUserNameUser(params: UpdateUserNameUserProps) {\n  try {\n    const { name,  pathname } = params;\n\n    const userSession = await currentUser();\n    if (!userSession) {\n      return null;\n    }\n\n  \n    const updatedUser = await database.user.update({\n      where: {\n        email: userSession.email!,\n      },\n      data: {\n        name: name,\n      },\n    });\n\n    if (!updatedUser) {\n      return { error: \"User not found\" };\n    }\n\n    userSession.name = updatedUser.name;\n  \n\n    revalidatePath(pathname);\n\n    return { success: \"User updated\" };\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\ntype SetNewPasswordProps = {\n  email: string;\n  newPassword: string;\n  path: string;\n};\nexport async function setNewPassword(params: SetNewPasswordProps) {\n  const { email, newPassword, path } = params;\n\n  try {\n    const user = await database.user.findFirst({\n      where: {\n        email : email,\n      },\n    });\n\n    if (!user) {\n      return { error: \"User Not Found\" };\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n    await database.user.update({\n      where: {\n        email : email,\n      },\n      data: {\n        password: hashedPassword,\n      },\n    });\n\n    revalidatePath(path);\n\n    return {\n      success:\n        \"Password Created. Now you can login with your email and new password.\",\n    };\n  } catch (error) {\n    console.error(error);\n    return { error: \"Something Went Wrong\" };\n  }\n}\n\ntype ChangePasswordProps = {\n  email: string;\n  newPassword: string;\n  oldPassword: string;\n  path: string;\n};\nexport async function changePassword(params: ChangePasswordProps) {\n  const { email, newPassword, oldPassword, path } = params;\n\n  try {\n    const user = await database.user.findFirst({\n      where: {\n        email : email,\n      },\n    });\n\n    if (!user) {\n      return { error: \"User Not Found\" };\n    }\n\n    const isMatch = await bcrypt.compare(oldPassword, user.password!);\n    if (!isMatch) {\n      return { error: \"Old password is incorrect\" };\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n    await database.user.update({\n      where: {\n        email : email,\n      },\n      data: {\n        password: hashedPassword,\n      },\n    });\n\n    revalidatePath(path);\n\n    return { success: \"Password Updated\" };\n  } catch (error) {\n    console.error(error);\n    return { error: \"Something Went Wrong\" };\n  }\n}\nexport async function deleteUser(password: string) {\n  try {\n    const userSession = await currentUser();\n\n    const user = await database.user.findFirst({\n      where: {\n        email: userSession?.email,\n      },\n    });\n\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password!);\n    if (!isMatch) {\n      return { error: \"Password is incorrect\" };\n    }\n\n    // TODO: Implement logic to delete all information about the user from all related schemas\n\n    await database.user.delete({\n      where: {\n        email: user.email!,\n      },\n    });\n\n    await signOut();\n\n    return { success: \"User deleted successfully\" };\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\n//[TwoFactorToggleServerAction]\n"
    }
  ],
  "type": "actions"
}
