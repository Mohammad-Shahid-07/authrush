{
  "name": "auth.actions.ts",
  "files": [
    {
      "name": "credentials",
      "imports": "import { LoginSchema, NewPasswordSchema, RegisterSchema, ResetSchema } from \"@/validations\";\n import * as z from \"zod\";\n import bcrypt from \"bcryptjs\";\n \n import { v4 as uuidv4 } from \"uuid\";\n import { sendResetEmail,  sendVerificationEmail } from \"@/lib/mail\";\n \nimport { signIn } from \"@/auth\"; \n import { DEFAULT_LOGIN_REDIRECT } from \"@/routes\";\nimport { getProfileUrl } from \"@/lib/constant\";\n",

      "content": "export async function RegisterUser(values: z.infer<typeof RegisterSchema>) {\n  try {\n    const validatedFields = RegisterSchema.safeParse(values);\n    if (!validatedFields.success) {\n      return { error: \"Invalid fields!\" };\n    }\n\n    const { email, password, name } = validatedFields.data;\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    const existingUser = await database.user.findFirst({\n      where: {\n        OR: [{ email: email }],\n      },\n    });\n\n    if (existingUser) {\n      return { error: \"Email or Username already in use!\" };\n    }\n    const image = getProfileUrl();\n    await database.user.create({\n      data: {\n        name,\n        email,\n        image,\n        password: hashedPassword,\n        //[RegisterUsername]\n      },\n    });\n\n    const Verificationtoken = await generateVerificationToken(email);\n    await sendVerificationEmail(name, email, Verificationtoken.token);\n\n    return { success: \"Confirmation email sent!\" };\n  } catch (error) {\n    return { error: \"Something went wrong!\" };\n  }\n} export async function LoginUser(\n  values: z.infer<typeof LoginSchema>,\n  callbackUrl?: string | null,\n) {\n  const validatedFields = LoginSchema.safeParse(values);\n\n  if (!validatedFields.success) {\n    return { error: \"Invalid fields!\" };\n  }\n\n  const { email, password } = validatedFields.data;\n\n  const existingUser = await database.user.findFirst({\n    where: {\n      OR: [{ email: email }],\n    },\n  });\n\n  if (!existingUser || !existingUser.email || !existingUser.password) {\n    return { error: \"Email does not exist!\" };\n  }\n\n  if (!existingUser.emailVerified) {\n    const verificationToken = await generateVerificationToken(\n      existingUser.email,\n    );\n\n    await sendVerificationEmail(\n      verificationToken.email,\n      verificationToken.token,\n    );\n\n    return { success: \"Confirmation email sent!\" };\n  }\n  //[PLoginTwoFactor]\n  \n  try {\n    await signIn(\"credentials\", {\n      email,\n      password,\n      redirectTo: callbackUrl || DEFAULT_LOGIN_REDIRECT,\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case \"CredentialsSignin\":\n          return { error: \"Invalid credentials!\" };\n        default:\n          return { error: \"Something went wrong!\" };\n      }\n    }\n\n    throw error;\n  }\n}\nexport async function getVerificationTokenByEmail(email: string) {\n  try {\n    const verificationToken = await database.emailVerification.findFirst({\n      where: {\n        email: email,\n      },\n    });\n    if (!verificationToken) {\n      return { error: \"Token not found\" };\n    }\n    return verificationToken;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\n      \"An error occurred while fetching verification token by email\",\n    );\n  }\n}\nexport async function getVerificationTokenByToken(token: string) {\n  try {\n    const verificationToken = await database.emailVerification.findFirst({\n      where: {\n        token: token,\n      },\n    });\n    if (!verificationToken) {\n      return { error: \"Token not found\" };\n    }\n    return verificationToken;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\n      \"An error occurred while fetching verification token by token\",\n    );\n  }\n}\n\nexport async function generateVerificationToken(email: string) {\n  try {\n    const token = uuidv4();\n    const expiresAt = new Date(new Date().getTime() + 1 * 60 * 60 * 1000);\n\n    await database.emailVerification.deleteMany({\n      where: {\n        email: email,\n      },\n    });\n\n    const newVerificationToken = await database.emailVerification.create({\n      data: {\n        email: email,\n        token: token,\n        expiresAt: expiresAt,\n      },\n    });\n\n    return newVerificationToken;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"An error occurred while generating verification token\");\n  }\n}\n\nexport async function verifyToken(token: string) {\n  try {\n    const existingToken = await database.emailVerification.findFirst({\n      where: {\n        token: token,\n      },\n    });\n\n    if (!existingToken) {\n      return { error: \"Token not found\" };\n    }\n\n    const hasExpired = new Date().getTime() > existingToken.expiresAt.getTime();\n    if (hasExpired) {\n      await database.emailVerification.delete({\n        where: {\n          token: token,\n        },\n      });\n      return { error: \"Token expired\" };\n    }\n\n    const { email } = existingToken;\n    const user = await database.user.findFirst({\n      where: {\n        email: email,\n      },\n    });\n\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n\n    await database.user.update({\n      where: {\n        email: email,\n      },\n      data: {\n        emailVerified: new Date(),\n        email: email,\n      },\n    });\n\n    await database.emailVerification.delete({\n      where: {\n        token: token,\n      },\n    });\n\n    return { success: \"Email Verified!\" };\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"An error occurred while verifying token\");\n  }\n}\n\nexport const generatePasswordResetToken = async (email: string) => {\n  try {\n    const token = uuidv4();\n    const expiresAt = new Date(new Date().getTime() + 60 * 60 * 1000);\n\n    await database.forgotPassword.deleteMany({\n      where: {\n        email: email,\n      },\n    });\n\n    const newPasswordResetToken = await database.forgotPassword.create({\n      data: {\n        email: email,\n        token: token,\n        expiresAt: expiresAt,\n      },\n    });\n\n    return newPasswordResetToken;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"An error occurred while generating password reset token\");\n  }\n};\nexport async function resetPassword(values: z.infer<typeof ResetSchema>) {\n  try {\n    const validatedFields = ResetSchema.safeParse(values);\n    if (!validatedFields.success) {\n      return { error: \"Please provide a valid email\" };\n    }\n\n    const { email } = validatedFields.data;\n\n    const user = await database.user.findUnique({\n      where: {\n        email: email,\n      },\n    });\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n\n    const verificationToken = await generatePasswordResetToken(email);\n\n    await sendResetEmail(user.name, verificationToken.email, verificationToken.token);\n\n    return { success: \"Password reset email sent\" };\n  } catch (error) {\n    console.error(error);\n    return { error: \"Something went wrong\" };\n  }\n}\n\nexport async function resetPasswordWithToken(\n  values: z.infer<typeof NewPasswordSchema>,\n  token: string,\n) {\n  try {\n    const validatedFields = NewPasswordSchema.safeParse(values);\n    if (!validatedFields.success) {\n      return { error: \"Please provide a valid email\" };\n    }\n\n    const { password } = validatedFields.data;\n\n    const existingToken = await database.forgotPassword.findFirst({\n      where: {\n        token: token,\n      },\n    });\n\n    if (!existingToken) {\n      return { error: \"Token not found\" };\n    }\n\n    const hasExpired = new Date().getTime() > existingToken.expiresAt.getTime();\n    if (hasExpired) {\n      await database.forgotPassword.delete({\n        where: {\n          token: token,\n        },\n      });\n      return { error: \"Token expired\" };\n    }\n\n    const user = await database.user.findFirst({\n      where: {\n        email: existingToken.email,\n      },\n    });\n\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    await database.user.update({\n      where: {\n        email: existingToken.email,\n      },\n      data: {\n        password: hashedPassword,\n      },\n    });\n\n    await database.forgotPassword.delete({\n      where: {\n        token: token,\n      },\n    });\n\n    return { success: \"Password reset\" };\n  } catch (error) {\n    console.error(error);\n    return { error: \"Something went wrong\" };\n  }\n} \n \n//[TwoFactorFunctions]",
      "comment": "//[CredentialsBase]"
    },
    {
      "name": "username",
      "imports": "",
      "content": "const existingUser = await database.user.findFirst({\n  where: {\n    OR: [{ email: email }, { username: username }],\n  },\n});",
      "comment": "const existingUser = await database.user.findFirst({\n      where: {\n        OR: [{ email: email }],\n      },\n    });"
    },
    {
      "name": "username",
      "imports": "",
      "content": "const existingLoginUser =await database.user.findFirst({\n  where: {\n    OR: [{ email: email }, { username: email }],\n  },\n})\n",
      "comment": "const existingLoginUser = await database.user.findFirst({\n      where: {\n        OR: [{ email: email }],\n      },\n    });"
    },
    {
      "name": "username",
      "imports": "",
      "content": "username,",
      "comment": "//[RegisterUsername]"
    },
    {
      "name": "username",
      "imports": "",
      "content": "const { name, email, password, username } = validatedFields.data;",
      "comment": "const { email, password, name } = validatedFields.data;"
    },
    {
      "name": "twoFactorAuth",
      "imports": "",
      "content": "const { email, password, code } = validatedFields.data;",
      "comment": "const { email, password } = validatedFields.data;;"
    },

    {
      "name": "twoFactorAuth",
      "imports": "import {sendTwoFactorTokenEmail} from \"@/lib/mail\";\n\n",
      "content": "\nif (existingUser.twoFactorEnabled && existingUser.email) {\n    if (code) {\n      const twoFactorToken = await database.twoFactorToken.findFirst({\n        where: {\n          token: code,\n        },\n      });\n\n      if (!twoFactorToken) {\n        return { error: \"Invalid code!\" };\n      }\n\n      if (twoFactorToken.token !== code) {\n        return { error: \"Invalid code!\" };\n      }\n\n      const hasExpired = new Date(twoFactorToken.expiresAt) < new Date();\n\n      if (hasExpired) {\n        return { error: \"Code expired!\" };\n      }\n\n      await database.twoFactorToken.delete({\n        where: { id: twoFactorToken.id },\n      });\n      const existingConfirmation = await database.twoFactorConfirmation.findFirst(\n        {\n          where: {\n            token: code,\n          },\n        },\n      );\n\n      if (existingConfirmation) {\n        await database.twoFactorConfirmation.delete({\n          where: { id: existingConfirmation.id },\n        });\n      }\n\n      await database.twoFactorConfirmation.create({\n        data: {\n          userId: existingUser.id,\n        },\n      });\n    } else {\n      const twoFactorToken = await generateTwoFactorToken(existingUser.email);\n      await sendTwoFactorTokenEmail(existingUser.name, existingUser.email, twoFactorToken.token);\n      return { twoFactor: true };\n    }\n  }\n",
      "comment": "//[PLoginTwoFactor]"
    },
    {
      "name": "twoFactorAuth",
      "imports": "import crypto from \"crypto\"",
      "content": "export async function generateTwoFactorToken(email: string) {\n  try {\n    const token = crypto.randomInt(100_100, 999_999).toString();\n    const expiresAt = new Date(new Date().getTime() + 15 * 60 * 1000);\n\n    // Delete any existing two-factor token for the given email\n    await database.twoFactorToken.deleteMany({\n      where: {\n        email: email,\n      },\n    });\n\n    // Create a new two-factor token\n    const newTwoFactorToken = await database.twoFactorToken.create({\n      data: {\n        email: email,\n        token: token,\n        expiresAt: expiresAt,\n      },\n    });\n\n    return newTwoFactorToken;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"An error occurred while generating two-factor token\");\n  }\n}\nexport async function getTwoFactorConfirmationByUserId(userId: string) {\n  try {\n    const twoFactorConfirmation = await database.twoFactorConfirmation.findFirst({\n      where: {\n        userId: userId,\n      },\n    });\n    if (!twoFactorConfirmation) {\n      return { error: \"Token not found\" };\n    }\n    return twoFactorConfirmation;\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"An error occurred while fetching two-factor confirmation\");\n  }\n}",
      "comment": "//[TwoFactorFunctions]"
    }
  ]
}
